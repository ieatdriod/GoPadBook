package tw.com.soyong.mebook;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;

//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Mebook
//  @ File Name : BMPGenerator.java
//  @ Date : 2009/3/23
//  @ Author : Victor
//
//

public class BMPGenerator {
	
	/*
	  typedef struct tagBITMAPFILEHEADER {
	  WORD    bfType;
	  DWORD   bfSize;
	  WORD    bfReserved1;
	  WORD    bfReserved2;
	  DWORD   bfOffBits;
	} BITMAPFILEHEADER, *PBITMAPFILEHEADER;
	 */	
	final static int BITMAP_FILE_HEADER_SIZE = 14;
 

	/*
	typedef struct tagBITMAPINFOHEADER{
	  DWORD  biSize;
	  LONG   biWidth;
	  LONG   biHeight;
	  WORD   biPlanes;
	  WORD   biBitCount;
	  DWORD  biCompression;
	  DWORD  biSizeImage;
	  LONG   biXPelsPerMeter;
	  LONG   biYPelsPerMeter;
	  DWORD  biClrUsed;
	  DWORD  biClrImportant;
	} BITMAPINFOHEADER, *PBITMAPINFOHEADER;
	 */
	
	final static int BITMAP_INFO_HEADER_SIZE = 40;	
	
	final static int swapEndian(int value) {
        int b1 = value & 0xff;
        int b2 = (value >> 8 ) & 0xff;
        int b3 = (value >> 16) & 0xff;
        int b4 = (value >> 24) & 0xff;
 
        return b1 << 24 | b2 << 16 | b3 << 8 | b4 << 0;

	}
	
	static public byte[] encodeBMP(byte[] dib) throws IOException {
        // the size of the BMP file in bytes
        int size = BITMAP_FILE_HEADER_SIZE + dib.length;
        ByteArrayOutputStream bytes = new ByteArrayOutputStream(size);
        DataOutputStream stream = new DataOutputStream(bytes);
        // HEADER
        // the magic number used to identify the BMP file: 0x42 0x4D
        stream.writeByte(0x42);
        stream.writeByte(0x4D);
        stream.writeInt(swapEndian(size));
        // reserved1 & 2
        stream.writeInt(0);

        ByteArrayInputStream bi = new ByteArrayInputStream(dib);
        int b1,b2,b3,b4 ;
        
        bi.skip(14);
        b1 = (int)bi.read() & 0xff;
        b2 = (int)bi.read() & 0xff;
        int biBitCount = (b2 << 8 | b1 << 0);

        bi.skip(16);
        b1 = (bi.read()&0xff) ;
        b2 = (bi.read()&0xff) ;
        b3 = (bi.read()&0xff) ;
        b4 = (bi.read()&0xff) ;

        bi.close();
        bi = null;
        
        int biClrUsed = (b4 << 24 | b3 << 16 | b2 << 8 |  b1) ;

        int palEntry = 0 ;
        palEntry = biClrUsed > 0 ? biClrUsed : ((biBitCount>8)? 0: 1<< biBitCount);
        palEntry *= 4 ;   // sizeof(RGBQUAD)
       
        // the offset, i.e. starting address of the bitmap data
        stream.writeInt(swapEndian(BITMAP_FILE_HEADER_SIZE + BITMAP_INFO_HEADER_SIZE + palEntry));

        // write dib data
        stream.write(dib, 0, dib.length);

        byte[] out = bytes.toByteArray();
        bytes.close();
        // quick consistency check
        if (out.length != size){
            throw new RuntimeException("bad math");
        }
/*        
        FileOutputStream test = new FileOutputStream("/sdcard/test.bmp");
        test.write(out);
        test.close();
*/        
        return out;	
	}
	
	private BMPGenerator() {
	}
}
