package tw.com.soyong.mebook;

import java.util.Arrays;
import java.util.Comparator;

import android.text.TextUtils;
import android.util.Log;

//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Mebook
//  @ File Name : SyParser.java
//  @ Date : 2009/3/23
//  @ Author : Victor
//
//

public class SyParser {
	
	private final static boolean DEBUG = false ;
	private final static String TAG = "SyParser";
	
	public SyParser() {
	}

	public final SyContent getContent(final String txt) throws MebookException {
		
		if (txt.length() <= 0 ){
			throw new MebookException();
		}
		
		MebookToken tokens = new MebookToken( txt );
		SyContent content = new SyContent();
		getContent( tokens , content);
		return content;
	}
	
	private Comparator<String> comparator = new Comparator<String>() {

		@Override
		public int compare(String arg0, String arg1) {
			int len1 = arg0.length();
			int len2 = arg1.length();
			return len1-len2;
		}
	};	

	// for overwrite use
	void getContent(final MebookToken tokens, SyContent content) throws MebookException {
		
		String strData ;
		SySentence sentence = null;
		int tokenID;
		while ( tokens.next()){
			strData = tokens.getData();
			tokenID = tokens.getID();
			switch( tokenID ){
			case MebookToken.TOK_TIME:
				sentence = timeProc( strData ,sentence, content);
				break;
			
			case MebookToken.TOK_ORG:
			case MebookToken.TOK_TRL:
			case MebookToken.TOK_SYN:
			case MebookToken.TOK_ANT:
			case MebookToken.TOK_EXT:
				sentence.setData(tokenID, strData);
				break;
				
			case MebookToken.TOK_HLT:
				final String[] aStr = TextUtils.split(strData, "[,]");
				Arrays.sort(aStr, comparator);
				sentence.mHlt = aStr ;
//				sentence.setData(tokenID, strData);
				break ;
				
			case MebookToken.TOK_VOC:
			case MebookToken.TOK_VO2:
				vocProc(strData, sentence);
				if ( DEBUG ) Log.d( TAG , "VOx:"+strData);
				break ;
				
			case MebookToken.TOK_CHP:
				chpProc(strData , content);
				break;
				
			case MebookToken.TOK_MRK:
				mrkProc(strData, sentence);
//				if ( DEBUG ) Log.d( TAG , "MRK:"+strData);
				break;
				
			case MebookToken.TOK_PIC:
				sentence.setData(tokenID, strData.substring(4));	//skip "PIC="
				break;				
				
			case MebookToken.TOK_POST:
				postscriptProc( strData ,content);
//				if ( DEBUG ) Log.d( TAG , "Ps:"+strData);
				break ;
				
			case MebookToken.TOK_EOS:{
				SyTime<Integer> syTime = getTime(strData);
				content.mEosTime = syTime ;
				
//				if ( DEBUG ) Log.d( TAG , "EOS:"+syTime.toString());
			}break;
			
			default:
				Log.e( TAG , "**Unknow token:"+strData);
				break;
			}
		}
		
		// check if any sentence not add into list
		if ( null != sentence && null == sentence.mEndTime && sentence.isDataValid(MebookToken.TOK_ORG) ) {
			
			sortVoc(sentence);			
			
			sentence.mEndTime = content.mEosTime;
			content.addSentence(sentence);
		}			
		
	}

	private void sortVoc(SySentence sentence) {
		// Sort voc
		if ( sentence.mVocInfo.size() > 0 ){
			
			int size = sentence.mVocInfo.size();
			SyVocInfo [] vocArr =  new SyVocInfo[size];
			sentence.mVocInfo.toArray(vocArr);
			Arrays.sort(vocArr , comparatorVoc );
			
			sentence.mVocInfo.clear();
			for (int i = 0 ; i < size ; i++){
				sentence.mVocInfo.add(vocArr[i]);	
			}
		}
	}
	
	private Comparator<SyVocInfo> comparatorVoc = new Comparator<SyVocInfo>() {

		@Override
		public int compare(SyVocInfo arg0, SyVocInfo arg1) {
			
			
			int ret = arg1.mVoc.compareTo(arg0.mVoc);
			return ret;
		}
	};	
	
	private void vocProc(String strData, SySentence sentence) throws MebookException {
			
		
		String str;
		SyVocInfo vocInfo = new SyVocInfo();
		
		
		str = getVocTime(strData, vocInfo);
		
		int index = str.indexOf('[');
		if ( -1 == index){
			throw new MebookException("voc miss [ tag");
		}
		
		vocInfo.mVoc = str.substring(0, index).trim();
		str = str.substring(index+1);
		
		final int len = str.length();
		char [] buf = new char[len] ;
		str.getChars(0, len, buf, 0);
		
		int phonEnd = -1 ;
		int deep = 0 ;
		for ( int i = 0 ; i < len ; ++i ){
			
			if ( buf[i] == ']'){
				if (0 == deep){
					phonEnd = i;
					break;
				}
				deep--;
			} else if( buf[i] == '['){ 
				deep ++ ;
			}
		}
		
		if ( -1 == phonEnd ){
			throw new MebookException("voc miss ] tag");
		}
		
		vocInfo.mOthers = str.substring(phonEnd+1).trim();
		
		
		str = str.substring(0, phonEnd);
		String[] aStr = TextUtils.split(str, "[#]");
		
		if ( 1 == aStr.length){				// no ## for hlt info
			vocInfo.mPhonetic = aStr[0].trim() ;
		}else if ( aStr.length > 1 ){
			vocInfo.mPhonetic = aStr[2].trim() ;
			
			str = aStr[1];
			String [] hltArr ;
			if (str.length() > 0) {
				if (str.charAt(0) == '<') {		// if star with "<" have time info
					vocInfo.mMiddleTime = getVocTime(str.substring(0, 9));
					str = str.substring(9);
				} 
				
				
				if ( true == MebookHelper.mIsJpBook ) {
					hltArr = new String[1];
					hltArr[0] = str ;
				}else {
					hltArr = TextUtils.split(str, "[,]");
					if (hltArr.length > 0) {
						Arrays.sort(hltArr, comparator);
						vocInfo.mHlt = hltArr;
					}
				}
			}
		}
		
		sentence.mVocInfo.add(vocInfo);
	}
	
	final private SyTime<Integer> getVocTime(final String strData) throws MebookException{
	
		String[] aStr = TextUtils.split(strData, "[<:.>]");

		final int count = aStr.length;
		if ( count < 4 ){					// <00:00.0> , will split for 4 part
			throw new MebookException();
		}
		
		int mm, ss , ff;
		mm = Integer.parseInt(aStr[1]) * 600;
		ss = Integer.parseInt(aStr[2]) * 10;
		ff = Integer.parseInt(aStr[3]);
		
		return new SyTime<Integer>((mm + ss + ff)*100);			
	}

	private String getVocTime(String strData, SyVocInfo vocInfo)
			throws MebookException {
		String strTime;
		String str;
		if ( strData.charAt(0) == '<' ){
			
			strTime = strData.substring(0 , 18);		// <00:00.0><99:99.9> ==> length =18 
			
			vocInfo.mBeginTime = getVocTime(strTime.substring(0,9));
			vocInfo.mEndTime = getVocTime(strTime.substring(9));
	
//			String[] aStr = TextUtils.split(strTime, "[<:.>]");
//
//			final int count = aStr.length;
//			if ( count < 8 ){
//				throw new MebookException();
//			}
			
			str = strData.substring(18);
		} else {
			str = strData;
		}
		return str ;
	}
	
	final private void mrkProc(String strData, SySentence sentence) {
		String str = strData.substring(4);		// "MRK="
		
		if ( str.length()> 0){
			sentence.setData(MebookToken.TOK_MRK, str);
		}else {
			sentence.setData(MebookToken.TOK_MRK, "0");
		}
	}

	final private void postscriptProc(final String strData, SyContent content) throws MebookException {
		
		PostscriptToken psToken = new PostscriptToken( strData );
		
		int par;
		String data ;
		boolean hasNex = psToken.next();
		int begin = 0 ;
		while(hasNex){
//			if ( PostscriptToken.TOK_PAR == psToken.getID() ){
				par = psToken.getPar();
				begin = psToken.getDataBegin();
				
				hasNex = psToken.next();
				if ( hasNex ){
					data = strData.substring(begin , psToken.getDataEnd()) ;
				} else {
					data = strData.substring(begin);
				}
				content.mPostscript.setData( par , data );
//			}
		}
	}

	final private SyTime<Integer> getTime(final String strData) throws MebookException {

		// <TIME=00:00.0> or <TIME=00:00> <TIME=97:00.9>
//		String[] aStr = TextUtils.split(strData.substring(5), "[:.]");	// skip "TIME="
		String[] aStr = TextUtils.split(strData, "[=:.]");	// skip "TIME="

		final int count = aStr.length;
		if ( count <= 0 ){
			throw new MebookException();
		}
		
		int frames = 0;
		
		int mm, ss;
		mm = Integer.parseInt(aStr[1]) * 600;
		ss = Integer.parseInt(aStr[2]) * 10;
		frames = mm + ss;		
		if (count >= 4) {
			frames = mm + ss + Integer.parseInt(aStr[3]);
		}
		
		SyTime<Integer> syTime = new SyTime<Integer>(frames* 100);  // in msec

		return syTime ;	
	}
	
	private SySentence timeProc(String strData, SySentence sentence, SyContent content) throws MebookException {
		SyTime<Integer> syTime = getTime(strData);
		
		// have previous sentence, set time to end time
		if ( null != sentence){
			sentence.mEndTime = syTime;
			
			sortVoc( sentence );
			content.addSentence(sentence);
		}

		// new sentence begin
		sentence = new SySentence();
		sentence.mBeginTime = syTime ;	
		
		
		int arrSize = content.mChapter.size();
		if ( arrSize > 0 ){
			arrSize -- ;
		}
		sentence.mChapterIndex = arrSize;
		return sentence ;
	}	

	
	final int getChpNo(final String txt){
		
        // <CHP=1,Ab>
		int number = 0 ;
        int index = txt.indexOf("," , 4);	// 4: "CHP="
        if ( -1 != index){
        	String str = txt.substring(4,index);
        	number = Integer.valueOf(str);
        }
        return number ;
	}
	
    final String getChpName(final String txt)
    {
        // <CHP=1,Ab>
    	String str = "";
        int index = txt.indexOf("," , 4);	// 4: "CHP="
        if ( -1 != index){
        	str = txt.substring(index+1);
        }
        return str;
    }	
	
	
	 void chpProc(String strData, SyContent content) {
		// <CHP=1,Ab>
		SyChapter chapter = new SyChapter();

		chapter.mNo = getChpNo(strData);
		chapter.mName = getChpName(strData);

		int index = content.getTotalSentence();
		chapter.mSentenceIndex = index+1;
//		if ( DEBUG ) Log.e(TAG , "mSentenceIndex:"+index + " chpProc:" + strData  );

		content.mChapter.add(chapter);
	}
}
